// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package controller

import (
	"sync"
	"water-jug-riddle-service/service"
)

var (
	lockServiceMockHealth sync.RWMutex
	lockServiceMockRiddle sync.RWMutex
)

// Ensure, that ServiceMock does implement service.Service.
// If this is not the case, regenerate this file with moq.
var _ service.Service = &ServiceMock{}

// ServiceMock is a mock implementation of service.Service.
//
//     func TestSomethingThatUsesService(t *testing.T) {
//
//         // make and configure a mocked service.Service
//         mockedService := &ServiceMock{
//             HealthFunc: func() *service.HealthResponse {
// 	               panic("mock out the Health method")
//             },
//             RiddleFunc: func(x int, y int, z int) (*service.RiddleResponse, *service.AppError) {
// 	               panic("mock out the Riddle method")
//             },
//         }
//
//         // use mockedService in code that requires service.Service
//         // and then make assertions.
//
//     }
type ServiceMock struct {
	// HealthFunc mocks the Health method.
	HealthFunc func() *service.HealthResponse

	// RiddleFunc mocks the Riddle method.
	RiddleFunc func(x int, y int, z int) (*service.RiddleResponse, *service.AppError)

	// calls tracks calls to the methods.
	calls struct {
		// Health holds details about calls to the Health method.
		Health []struct {
		}
		// Riddle holds details about calls to the Riddle method.
		Riddle []struct {
			// X is the x argument value.
			X int
			// Y is the y argument value.
			Y int
			// Z is the z argument value.
			Z int
		}
	}
}

// Health calls HealthFunc.
func (mock *ServiceMock) Health() *service.HealthResponse {
	if mock.HealthFunc == nil {
		panic("ServiceMock.HealthFunc: method is nil but Service.Health was just called")
	}
	callInfo := struct {
	}{}
	lockServiceMockHealth.Lock()
	mock.calls.Health = append(mock.calls.Health, callInfo)
	lockServiceMockHealth.Unlock()
	return mock.HealthFunc()
}

// HealthCalls gets all the calls that were made to Health.
// Check the length with:
//     len(mockedService.HealthCalls())
func (mock *ServiceMock) HealthCalls() []struct {
} {
	var calls []struct {
	}
	lockServiceMockHealth.RLock()
	calls = mock.calls.Health
	lockServiceMockHealth.RUnlock()
	return calls
}

// Riddle calls RiddleFunc.
func (mock *ServiceMock) Riddle(x int, y int, z int) (*service.RiddleResponse, *service.AppError) {
	if mock.RiddleFunc == nil {
		panic("ServiceMock.RiddleFunc: method is nil but Service.Riddle was just called")
	}
	callInfo := struct {
		X int
		Y int
		Z int
	}{
		X: x,
		Y: y,
		Z: z,
	}
	lockServiceMockRiddle.Lock()
	mock.calls.Riddle = append(mock.calls.Riddle, callInfo)
	lockServiceMockRiddle.Unlock()
	return mock.RiddleFunc(x, y, z)
}

// RiddleCalls gets all the calls that were made to Riddle.
// Check the length with:
//     len(mockedService.RiddleCalls())
func (mock *ServiceMock) RiddleCalls() []struct {
	X int
	Y int
	Z int
} {
	var calls []struct {
		X int
		Y int
		Z int
	}
	lockServiceMockRiddle.RLock()
	calls = mock.calls.Riddle
	lockServiceMockRiddle.RUnlock()
	return calls
}
